import logging
from typing import Optional

from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_unidirectional_edge import (
    UnidirectionalEdge,
)
from videoipath_automation_tool.connector.vip_connector import VideoIPathConnector
from videoipath_automation_tool.apps.topology.topology_api import TopologyAPI
from videoipath_automation_tool.apps.topology.model.topology_device import TopologyDevice
from videoipath_automation_tool.apps.topology.helper.placement import TopologyPlacement
from videoipath_automation_tool.utils.cross_app_utils import validate_device_id_string


class TopologyApp:
    def __init__(self, vip_connector: VideoIPathConnector, logger: Optional[logging.Logger] = None):
        """TopologyApp contains functionality to interact with the VideoIPath Topology.

        Args:
            vip_connector (VideoIPathConnector): VideoIPathConnector instance to handle the connection to the VideoIPath-Server.
            logger (Optional[logging.Logger], optional): Logger instance to use for logging.
        """
        # --- Setup Logging ---
        if logger is None:
            self._logger = logging.getLogger(
                "videoipath_automation_tool_inventory_app"
            )  # create fallback logger if no logger is provided
            self._logger.debug(
                "No logger for Topology App provided. Creating fallback logger: 'videoipath_automation_tool_inventory_app'."
            )
        else:
            self._logger = logger

        # --- Setup Topology API ---
        try:
            self._topology_api = TopologyAPI(vip_connector=vip_connector, logger=self._logger)
            self._logger.debug("Topology API successfully initialized.")
        except Exception as e:
            self._logger.error(f"Error initializing Topology API: {e}")
            raise ConnectionError("Error initializing Topology API.")

        # --- Setup Placement Layer ---
        self.placement = TopologyPlacement(self._topology_api, self._logger)

        # --- Setup Experimental Layer ---
        self.experimental = TopologyExperimental(self._topology_api, self._logger)

    def get_device(self, device_id: str) -> TopologyDevice:
        """Get a topology device by its device id. If the device does not exist, method will try to create the device from the driver.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            TopologyDevice: TopologyDevice object.
        """
        if not validate_device_id_string(device_id=device_id, include_virtual=True):
            message = f"Device id '{device_id}' is not a valid device id."
            self._logger.debug(message)
            raise ValueError(message)

        if not self._topology_api.check_device_in_topology_available(device_id):
            self._logger.info(f"Device with id '{device_id}' not found in topology, create device from driver.")
            if not self.check_device_from_driver_available(device_id):
                raise ValueError(f"Device with id '{device_id}' not found in topology and driver not available")
            return self._topology_api.get_device_from_driver(device_id)
        else:
            return self._topology_api.get_device_from_topology(device_id)

    def update_device(self, device: TopologyDevice) -> TopologyDevice:
        if self.check_device_in_topology_available(device.configuration.base_device.id):
            changes = self._topology_api.analyze_device_configuration_changes(device)
            self._logger.debug(f"Changes: {changes.get_changed_elements()}")
            response = self._topology_api.apply_device_configuration_changes(changes)
            self._logger.info(f"Device '{device.configuration.base_device.label}' updated in topology.")
        else:
            response = self._topology_api.add_device_initially(device)
            self._logger.info(f"Device '{device.configuration.base_device.label}' added to topology.")
        return_device = self._topology_api.get_device_from_topology(device.configuration.base_device.id)
        return return_device

    def get_device_from_driver(self, device_id: str) -> TopologyDevice:
        """Get a device generated by VideoIPath via the driver.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            TopologyDevice: TopologyDevice object.
        """
        return self._topology_api.get_device_from_driver(device_id)

    def check_device_from_driver_available(self, device_id: str) -> bool:
        """Check if the representation generated by a driver is available for a device.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            bool: True if the representation generated by a driver is available, False otherwise.
        """
        return self._topology_api.check_device_from_driver_available(device_id)

    def check_device_in_topology_available(self, device_id: str) -> bool:
        """Check if a device exists in the topology.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            bool: True if the device exists, False otherwise.
        """
        return self._topology_api.check_device_in_topology_available(device_id)

    def add_device_initially(self, device: TopologyDevice):
        """Add a device to the topology.

        Args:
            device (TopologyDevice): TopologyDevice object.

        Returns:
            RequestRestV2: RequestRestV2 object.
        """
        return self._topology_api.add_device_initially(device)

    def create_edges(
        self,
        device_1_id: str,
        device_1_vertex_factory_label: str,
        device_2_id: str,
        device_2_vertex_factory_label: str,
        bandwidth: Optional[int] = None,
        bandwidth_factor: Optional[float] = None,
        redundancy_mode: Optional[str] = None,
    ) -> list[UnidirectionalEdge]:
        device_1 = self.get_device(device_1_id)
        device_2 = self.get_device(device_2_id)
        device_1_vertices = device_1.configuration.get_ip_vertex_by_label(device_1_vertex_factory_label)
        device_2_vertices = device_2.configuration.get_ip_vertex_by_label(device_2_vertex_factory_label)
        if not device_1_vertices:
            raise ValueError(
                f"Vertex with label '{device_1_vertex_factory_label}' not found in device '{device_1.configuration.base_device.label}'."
            )
        if not device_2_vertices:
            raise ValueError(
                f"Vertex with label '{device_2_vertex_factory_label}' not found in device '{device_2.configuration.base_device.label}'."
            )

        # print(device_1_vertices)
        # print(device_2_vertices)

        if "in" in device_1_vertices and "out" in device_1_vertices:
            if device_1_vertices["in"] and device_1_vertices["out"]:
                device_1_status = "both"
            elif device_1_vertices["out"]:
                device_1_status = "out"
            elif device_1_vertices["in"]:
                device_1_status = "in"
            else:
                device_1_status = None

        if "in" in device_2_vertices and "out" in device_2_vertices:
            if device_2_vertices["in"] and device_2_vertices["out"]:
                device_2_status = "both"
            elif device_2_vertices["out"]:
                device_2_status = "out"
            elif device_2_vertices["in"]:
                device_2_status = "in"
            else:
                device_2_status = None

        if not device_1_status or not device_2_status:
            raise ValueError("Invalid vertex configuration.")

        edges = []  # type: list[UnidirectionalEdge]

        if device_1_status == "both" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "both" and device_2_status == "out":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )
        elif device_1_status == "both" and device_2_status == "in":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "out" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "in" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )

        if bandwidth:
            for edge in edges:
                edge.bandwidth = bandwidth
                if bandwidth_factor:
                    edge.bandwidth = int(bandwidth * bandwidth_factor)

        if redundancy_mode:
            if redundancy_mode == "OnlyMain" or redundancy_mode == "OnlySpare" or redundancy_mode == "Any":
                for edge in edges:
                    edge.redundancyMode = redundancy_mode
            else:
                raise ValueError("Invalid redundancy mode, must be 'OnlyMain', 'OnlySpare' or 'Any'.")

        for edge in edges:
            self._logger.info(f"Edge created: {edge.factory_label}")
        return edges


class TopologyExperimental:
    def __init__(self, topology_api: TopologyAPI, logger: logging.Logger):
        self._topology_api = topology_api
        self._logger = logger

    def auto_create_edge(
        self,
        device_1: TopologyDevice,
        device_1_vertex_label: str,
        device_2: TopologyDevice,
        device_2_vertex_label: str,
        bandwidth: Optional[int] = None,
        bandwidth_factor: Optional[float] = None,
        redundancy_mode: Optional[str] = None,
    ) -> list[UnidirectionalEdge]:
        device_1_vertices = device_1.configuration.get_ip_vertex_by_label(device_1_vertex_label)
        device_2_vertices = device_2.configuration.get_ip_vertex_by_label(device_2_vertex_label)
        if not device_1_vertices:
            raise ValueError(
                f"Vertex with label '{device_1_vertex_label}' not found in device '{device_1.configuration.base_device.label}'."
            )
        if not device_2_vertices:
            raise ValueError(
                f"Vertex with label '{device_2_vertex_label}' not found in device '{device_2.configuration.base_device.label}'."
            )

        if "in" in device_1_vertices and "out" in device_1_vertices:
            if device_1_vertices["in"] and device_1_vertices["out"]:
                device_1_status = "both"
            elif device_1_vertices["out"]:
                device_1_status = "out"
            elif device_1_vertices["in"]:
                device_1_status = "in"
            else:
                device_1_status = None

        if "in" in device_2_vertices and "out" in device_2_vertices:
            if device_2_vertices["in"] and device_2_vertices["out"]:
                device_2_status = "both"
            elif device_2_vertices["out"]:
                device_2_status = "out"
            elif device_2_vertices["in"]:
                device_2_status = "in"
            else:
                device_2_status = None

        if not device_1_status or not device_2_status:
            raise ValueError("Invalid vertex configuration.")

        edges = []  # type: list[UnidirectionalEdge]

        if device_1_status == "both" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "both" and device_2_status == "out":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )
        elif device_1_status == "both" and device_2_status == "in":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "out" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "in" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )

        if bandwidth:
            for edge in edges:
                edge.bandwidth = bandwidth
                if bandwidth_factor:
                    edge.bandwidth = int(bandwidth * bandwidth_factor)

        if redundancy_mode:
            if redundancy_mode == "OnlyMain" or redundancy_mode == "OnlySpare" or redundancy_mode == "Any":
                for edge in edges:
                    edge.redundancyMode = redundancy_mode
            else:
                raise ValueError("Invalid redundancy mode, must be 'OnlyMain', 'OnlySpare' or 'Any'.")

        return edges


class TopologySynchronize:
    def __init__(self) -> None:
        pass

    def say_hello(self):
        print("Hello from TopologySynchronize!")

    # def create_topology_device_from_driver_template(self, device_id: str, force: bool = False) -> TopologyDevice:
    #     """
    #     Create a topology device object by device id from the initial configuration created by VideoIPath via the driver.
    #     """

    #     if not device_id.startswith("device"):
    #         raise ValueError(f"Unknown id format: {device_id}")
    #     if self._topology_api.get_filtered_nGraphElements_config_by_device_id(device_id, "baseDevice") != [] and not force:
    #         raise ValueError(f"Device with id {device_id} already exists in the topology!")

    #     logging.debug(f"Creating TopologyDevice from driver template with device id '{device_id}':")

    #     template_dict = self._topology_api.get_nGraphFromDriver_config_by_device_id(device_id)
    #     codec_vertices = []
    #     generic_vertices = []
    #     ip_vertices = []
    #     edges = []
    #     for key in template_dict:
    #         if key != "_id" and key != "_vid":      # ignore entry with device_id
    #             initial_config = {"_id": key,
    #                         "_rev": None,
    #                         "_vid": key,
    #                         **template_dict[key]}
    #             logging.debug(f"nGraphElement '{key}' / Type '{template_dict[key]['type']}' created.")
    #             if template_dict[key]["type"] == "baseDevice":
    #                 base_device = BaseDevice(**initial_config)
    #             elif template_dict[key]["type"] == "codecVertex":
    #                 codec_vertices.append(CodecVertex(**initial_config))
    #             elif template_dict[key]["type"] == "genericVertex":
    #                 generic_vertices.append(GenericVertex(**initial_config))
    #             elif template_dict[key]["type"] == "ipVertex":
    #                 ip_vertices.append(IpVertex(**initial_config))
    #             elif template_dict[key]["type"] == "unidirectionalEdge":
    #                 edges.append(UnidirectionalEdge(**initial_config))
    #             else:
    #                 raise ValueError(f"Unknown nGraphElement type: {template_dict[key]['type']}")
    #         sorted_edges = sort_edges(edges, device_id)
    #         internal_edges = sorted_edges["internal_edges"]
    #         external_edges = sorted_edges["external_edges"]
    #     return TopologyDevice.from_nGraphElements(base_device, codec_vertices, generic_vertices, ip_vertices, internal_edges, external_edges)

    # def get_device(self, device_id: str) -> TopologyDevice:
    #     base_device = BaseDevice(**self._topology_api.get_filtered_nGraphElements_config_by_device_id(device_id, "baseDevice")[0]) # only one baseDevice per device_id
    #     codec_vertices = [CodecVertex(**config) for config in self._topology_api.get_filtered_nGraphElements_config_by_device_id(device_id, "codecVertex")]
    #     generic_vertices = [GenericVertex(**config) for config in self._topology_api.get_filtered_nGraphElements_config_by_device_id(device_id, "genericVertex")]
    #     ip_vertices = [IpVertex(**config) for config in self._topology_api.get_filtered_nGraphElements_config_by_device_id(device_id, "ipVertex")]
    #     unidirectional_edges = [UnidirectionalEdge(**config) for config in self._topology_api.get_filtered_nGraphElements_config_by_device_id(device_id, "unidirectionalEdge")]
    #     sorted_edges = sort_edges(unidirectional_edges, device_id)
    #     internal_edges = sorted_edges["internal_edges"]
    #     external_edges = sorted_edges["external_edges"]
    #     return TopologyDevice.from_nGraphElements(base_device, codec_vertices, generic_vertices, ip_vertices, internal_edges, external_edges)


# TODO: Implement methods for editing the device configuration and pushing the changes to the VideoIPath API

#     def update_device(self, device: TopologyDevice):
#         # TODO -> implement update_device! This is just a placeholder
#         n_graph_elements = []
#         n_graph_elements.append(device.configuration.base_device)
#         n_graph_elements.extend(device.configuration.codec_vertices)
#         n_graph_elements.extend(device.configuration.generic_vertices)
#         n_graph_elements.extend(device.configuration.ip_vertices)
#         n_graph_elements.extend(device.configuration.internal_edges)
#         n_graph_elements.extend(device.configuration.external_edges)
#         returnvalue = self._topology_api.update_nGraphElement(n_graph_elements, action="replace")

#     def add_device(self, device: TopologyDevice):
#         n_graph_elements = []
#         n_graph_elements.append(device.configuration.base_device)
#         n_graph_elements.extend(device.configuration.codec_vertices)
#         n_graph_elements.extend(device.configuration.generic_vertices)
#         n_graph_elements.extend(device.configuration.ip_vertices)
#         n_graph_elements.extend(device.configuration.internal_edges)
#         n_graph_elements.extend(device.configuration.external_edges)
#         return self._topology_api.update_nGraphElement(n_graph_elements, action="add")


#     # def create_unidirectional_edge_pair(self, source_device_id: str, source_port_label: str, target_device_id: str, target_port_label: str):
#     #     source_device = self.get_device(source_device_id)
#     #     target_device = self.get_device(target_device_id)

#     #     if not source_device:
#     #         raise ValueError(f"Device with id '{source_device_id}' not found.")
#     #     if not target_device:
#     #         raise ValueError(f"Device with id '{target_device_id}' not found.")

#     #     # Find id of the source and target port

#     #     edges = [{
#     #         "source": "target_id",
#     #         "target": "source_id"
#     #     },
#     #     {
#     #         "source": "target_id",
#     #         "target": "source_id"
#     #     }]

#     #     for port in source_device.configuration.ip_vertices:
#     #         if port.gpid.pointId[-1] == source_port_label:
#     #             if "in" in port.id:
#     #                 edges[1]["target"] = port.id
#     #             elif "out" in port.id:
#     #                 edges[0]["source"] = port.id
#     #     if not edges[0]["source"] or not edges[0]["target"]:
#     #         raise ValueError(f"Ports with label '{source_port_label}' not found on device '{source_device_id}'. Need two ports for bidirectional edge.")

#     #     for port in target_device.configuration.ip_vertices:
#     #         if port.gpid.pointId[-1] == target_port_label:
#     #             if "in" in port.id:
#     #                 edges[0]["target"] = port.id
#     #             elif "out" in port.id:
#     #                 edges[1]["source"] = port.id
#     #     if not edges[1]["source"] or not edges[1]["target"]:
#     #         raise ValueError(f"Ports with label '{target_port_label}' not found on device '{target_device_id}'. Need two ports for bidirectional edge.")

#     #     ip_vertices = []
#     #     for edge in edges:
#     #         default_edge = {
#     #             "_id": f"{edge['source']}::{edge['target']}",
#     #             "_rev": None,
#     #             "_vid": f"{edge['source']}::{edge['target']}",
#     #             "active": True,
#     #             "bandwidth": -1.0,
#     #             "capacity": 65535,
#     #             "conflictPri": 0,
#     #             "descriptor": {
#     #                 "desc": "",
#     #                 "label": f"{edge['source']} -> {edge['target']}"
#     #             },
#     #             "excludeFormats": [],
#     #             "fDescriptor": {
#     #                 "desc": "",
#     #                 "label": ""
#     #             },
#     #             "fromId": edge["source"],
#     #             "includeFormats": [],
#     #             "redundancyMode": "OnlyMain",
#     #             "tags": [],
#     #             "toId": edge["target"],
#     #             "type": "unidirectionalEdge",
#     #             "weight": 1,
#     #             "weightFactors": {
#     #                 "bandwidth": {
#     #                     "weight": 0
#     #                 },
#     #                 "service": {
#     #                     "max": 100,
#     #                     "weight": 0
#     #                 }
#     #             }
#     #         }
#     #         unidirectional_edge = UnidirectionalEdge(**default_edge)
#     #         print(unidirectional_edge)
#     #         # ip_vertices.append(unidirectional_edge)

# '''
#  {
#                             "_id": "device0.1.Ethernet4.out::device7.0.tap0.in",
#                             "_rev": "1-065ef6fc-2ba6-432e-8952-2e04fe3dab5b",
#                             "_vid": "device0.1.Ethernet4.out::device7.0.tap0.in",
#                             "active": true,
#                             "bandwidth": -1.0,
#                             "capacity": 65535,
#                             "conflictPri": 0,
#                             "descriptor": {
#                                 "desc": "",
#                                 "label": "Ethernet4 (out) -> tap0 (in)"
#                             },
#                             "excludeFormats": [],
#                             "fDescriptor": {
#                                 "desc": "",
#                                 "label": ""
#                             },
#                             "fromId": "device0.1.Ethernet4.out",
#                             "includeFormats": [],
#                             "redundancyMode": "OnlyMain",
#                             "tags": [],
#                             "toId": "device7.0.tap0.in",
#                             "type": "unidirectionalEdge",
#                             "weight": 1,
#                             "weightFactors": {
#                                 "bandwidth": {
#                                     "weight": 0
#                                 },
#                                 "service": {
#                                     "max": 100,
#                                     "weight": 0
#                                 }
#                             }
#                         },
# '''
#     # def push_device(self, device: TopologyDevice):
#     #     self._topology_api.update_nGraphElement(device.base)
#     #     codec_list = [codec for codec in device.codecVertices]
#     #     self._topology_api.update_nGraphElement_list(codec_list)
#     #     ip_list = [ip for ip in device.ipVertices]
#     #     self._topology_api.update_nGraphElement_list(ip_list)
#     #     generic_list = [generic for generic in device.genericVertices]
#     #     self._topology_api.update_nGraphElement_list(generic_list)

#     #     # for codec in device.codecVertices:
#     #     #     self._topology_api.update_nGraphElement(codec)
#     #     # for ip in device.ipVertices:
#     #     #     self._topology_api.update_nGraphElement(ip)
#     #     # for generic in device.genericVertices:
#     #     #     self._topology_api.update_nGraphElement(generic)
#     #     # for edge in device.unidirectionalEdges:
#     #     #     self._topology_api.update_nGraphElement(edge)
