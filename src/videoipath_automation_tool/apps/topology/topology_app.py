import logging
from typing import List, Literal, Optional

from videoipath_automation_tool.apps.topology.helper.placement import TopologyPlacement
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_base_device import BaseDevice
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_codec_vertex import CodecVertex
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_generic_vertex import GenericVertex
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_ip_vertex import IpVertex
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_unidirectional_edge import (
    UnidirectionalEdge,
)
from videoipath_automation_tool.apps.topology.model.topology_device import TopologyDevice
from videoipath_automation_tool.apps.topology.topology_api import TopologyAPI
from videoipath_automation_tool.connector.vip_connector import VideoIPathConnector
from videoipath_automation_tool.utils.cross_app_utils import validate_device_id_string


class TopologyApp:
    def __init__(self, vip_connector: VideoIPathConnector, logger: Optional[logging.Logger] = None):
        """TopologyApp contains functionality to interact with the VideoIPath Topology.

        Args:
            vip_connector (VideoIPathConnector): VideoIPathConnector instance to handle the connection to the VideoIPath-Server.
            logger (Optional[logging.Logger], optional): Logger instance to use for logging.
        """
        # --- Setup Logging ---
        if logger is None:
            self._logger = logging.getLogger(
                "videoipath_automation_tool_inventory_app"
            )  # create fallback logger if no logger is provided
            self._logger.debug(
                "No logger for Topology App provided. Creating fallback logger: 'videoipath_automation_tool_inventory_app'."
            )
        else:
            self._logger = logger

        # --- Setup Topology API ---
        try:
            self._topology_api = TopologyAPI(vip_connector=vip_connector, logger=self._logger)
            self._logger.debug("Topology API successfully initialized.")
        except Exception as e:
            self._logger.error(f"Error initializing Topology API: {e}")
            raise ConnectionError("Error initializing Topology API.")

        # --- Setup Placement Layer ---
        self.placement = TopologyPlacement(self._topology_api, self._logger)

        # --- Setup Experimental Layer ---
        self.experimental = TopologyExperimental(self._topology_api, self._logger)

    def get_device(self, device_id: str) -> TopologyDevice:
        """Get a topology device by its device id. If the device does not exist, method will try to create the device from the driver.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            TopologyDevice: TopologyDevice object.
        """
        if not validate_device_id_string(device_id=device_id, include_virtual=True):
            message = f"Device id '{device_id}' is not a valid device id."
            self._logger.debug(message)
            raise ValueError(message)

        if not self._topology_api.check_device_in_topology_available(device_id):
            self._logger.info(f"Device with id '{device_id}' not found in topology, create device from driver.")
            if not self.check_device_from_driver_available(device_id):
                raise ValueError(f"Device with id '{device_id}' not found in topology and driver not available")
            return self._topology_api.get_device_from_driver(device_id)
        else:
            return self._topology_api.get_device_from_topology(device_id)

    def update_device(self, device: TopologyDevice) -> TopologyDevice:
        if self.check_device_in_topology_available(device.configuration.base_device.id):
            changes = self._topology_api.analyze_device_configuration_changes(device)
            self._logger.debug(f"Changes: {changes.get_changed_elements()}")
            response = self._topology_api.apply_device_configuration_changes(changes)
            if response:
                self._logger.info(f"Device '{device.configuration.base_device.label}' updated in topology.")
            else:
                self._logger.info(f"No changes detected for device '{device.configuration.base_device.label}'.")
        else:
            response = self._topology_api.add_device_initially(device)
            self._logger.info(f"Device '{device.configuration.base_device.label}' added to topology.")
        return_device = self._topology_api.get_device_from_topology(device.configuration.base_device.id)
        return return_device

    def get_device_from_driver(self, device_id: str) -> TopologyDevice:
        """Get a device generated by VideoIPath via the driver.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            TopologyDevice: TopologyDevice object.
        """
        return self._topology_api.get_device_from_driver(device_id)

    def get_vertex_by_id(self, vertex_id: str):
        """
        Get a vertex by its unique id.

        Args:
            vertex_id (str): Unique Vertex id.
        """
        return self._topology_api._fetch_nGraphElement_by_key(vertex_id)

    def get_vertex_by_label(
        self, vertex_label: str, mode: Literal["user_defined", "factory"] = "user_defined"
    ) -> (
        BaseDevice
        | CodecVertex
        | IpVertex
        | UnidirectionalEdge
        | GenericVertex
        | List[BaseDevice | CodecVertex | IpVertex | UnidirectionalEdge | GenericVertex]
    ):
        """
        Get a vertex by its user defined label.
        In case of multiple vertices with the same label, a list of vertices will be returned.

        Args:
            vertex_label (str): User defined Vertex label.
        """
        return self._topology_api.get_vertex_by_label(vertex_label, mode)

    def update_vertex(self, vertex: BaseDevice | CodecVertex | IpVertex | UnidirectionalEdge | GenericVertex):
        """
        Update a single vertex in the topology.

        Args:
            vertex (BaseDevice | CodecVertex | IpVertex | UnidirectionalEdge | GenericVertex): Vertex object.
        """
        return self._topology_api.update_single_nGraphElement(vertex)

    def check_device_from_driver_available(self, device_id: str) -> bool:
        """Check if the representation generated by a driver is available for a device.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            bool: True if the representation generated by a driver is available, False otherwise.
        """
        return self._topology_api.check_device_from_driver_available(device_id)

    def check_device_in_topology_available(self, device_id: str) -> bool:
        """Check if a device exists in the topology.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            bool: True if the device exists, False otherwise.
        """
        return self._topology_api.check_device_in_topology_available(device_id)

    def add_device_initially(self, device: TopologyDevice):
        """Add a device to the topology.

        Args:
            device (TopologyDevice): TopologyDevice object.

        Returns:
            RequestRestV2: RequestRestV2 object.
        """
        return self._topology_api.add_device_initially(device)

    def create_edges(
        self,
        device_1_id: str,
        device_1_vertex_factory_label: str,
        device_2_id: str,
        device_2_vertex_factory_label: str,
        bandwidth: Optional[int] = None,
        bandwidth_factor: Optional[float] = None,
        redundancy_mode: Optional[str] = None,
    ) -> list[UnidirectionalEdge]:
        """
        The method will automatically determine the correct edge configuration based on the vertex configuration of the devices.
        """
        device_1 = self.get_device(device_1_id)
        device_2 = self.get_device(device_2_id)
        device_1_vertices = device_1.configuration.get_ip_vertex_by_label(device_1_vertex_factory_label)
        device_2_vertices = device_2.configuration.get_ip_vertex_by_label(device_2_vertex_factory_label)
        if not device_1_vertices:
            raise ValueError(
                f"Vertex with label '{device_1_vertex_factory_label}' not found in device '{device_1.configuration.base_device.label}'."
            )
        if not device_2_vertices:
            raise ValueError(
                f"Vertex with label '{device_2_vertex_factory_label}' not found in device '{device_2.configuration.base_device.label}'."
            )

        # print(device_1_vertices)
        # print(device_2_vertices)

        if "in" in device_1_vertices and "out" in device_1_vertices:
            if device_1_vertices["in"] and device_1_vertices["out"]:
                device_1_status = "both"
            elif device_1_vertices["out"]:
                device_1_status = "out"
            elif device_1_vertices["in"]:
                device_1_status = "in"
            else:
                device_1_status = None

        if "in" in device_2_vertices and "out" in device_2_vertices:
            if device_2_vertices["in"] and device_2_vertices["out"]:
                device_2_status = "both"
            elif device_2_vertices["out"]:
                device_2_status = "out"
            elif device_2_vertices["in"]:
                device_2_status = "in"
            else:
                device_2_status = None

        if not device_1_status or not device_2_status:
            raise ValueError("Invalid vertex configuration.")

        edges = []  # type: list[UnidirectionalEdge]

        if device_1_status == "both" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "both" and device_2_status == "out":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )
        elif device_1_status == "both" and device_2_status == "in":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "out" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "in" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )

        if bandwidth:
            for edge in edges:
                edge.bandwidth = bandwidth
                if bandwidth_factor:
                    edge.bandwidth = int(bandwidth * bandwidth_factor)

        if redundancy_mode:
            if redundancy_mode == "OnlyMain" or redundancy_mode == "OnlySpare" or redundancy_mode == "Any":
                for edge in edges:
                    edge.redundancyMode = redundancy_mode
            else:
                raise ValueError("Invalid redundancy mode, must be 'OnlyMain', 'OnlySpare' or 'Any'.")

        for edge in edges:
            self._logger.info(f"Edge created: {edge.factory_label}")
        return edges


class TopologyExperimental:
    def __init__(self, topology_api: TopologyAPI, logger: logging.Logger):
        self._topology_api = topology_api
        self._logger = logger

    def auto_create_edge(
        self,
        device_1: TopologyDevice,
        device_1_vertex_label: str,
        device_2: TopologyDevice,
        device_2_vertex_label: str,
        bandwidth: Optional[int] = None,
        bandwidth_factor: Optional[float] = None,
        redundancy_mode: Optional[str] = None,
    ) -> list[UnidirectionalEdge]:
        device_1_vertices = device_1.configuration.get_ip_vertex_by_label(device_1_vertex_label)
        device_2_vertices = device_2.configuration.get_ip_vertex_by_label(device_2_vertex_label)
        if not device_1_vertices:
            raise ValueError(
                f"Vertex with label '{device_1_vertex_label}' not found in device '{device_1.configuration.base_device.label}'."
            )
        if not device_2_vertices:
            raise ValueError(
                f"Vertex with label '{device_2_vertex_label}' not found in device '{device_2.configuration.base_device.label}'."
            )

        if "in" in device_1_vertices and "out" in device_1_vertices:
            if device_1_vertices["in"] and device_1_vertices["out"]:
                device_1_status = "both"
            elif device_1_vertices["out"]:
                device_1_status = "out"
            elif device_1_vertices["in"]:
                device_1_status = "in"
            else:
                device_1_status = None

        if "in" in device_2_vertices and "out" in device_2_vertices:
            if device_2_vertices["in"] and device_2_vertices["out"]:
                device_2_status = "both"
            elif device_2_vertices["out"]:
                device_2_status = "out"
            elif device_2_vertices["in"]:
                device_2_status = "in"
            else:
                device_2_status = None

        if not device_1_status or not device_2_status:
            raise ValueError("Invalid vertex configuration.")

        edges = []  # type: list[UnidirectionalEdge]

        if device_1_status == "both" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "both" and device_2_status == "out":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )
        elif device_1_status == "both" and device_2_status == "in":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "out" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_1_vertices["out"], to_ip_vertex=device_2_vertices["in"]
                )
            )
        elif device_1_status == "in" and device_2_status == "both":
            edges.append(
                UnidirectionalEdge.create(
                    preset="arista", from_ip_vertex=device_2_vertices["out"], to_ip_vertex=device_1_vertices["in"]
                )
            )

        if bandwidth:
            for edge in edges:
                edge.bandwidth = bandwidth
                if bandwidth_factor:
                    edge.bandwidth = int(bandwidth * bandwidth_factor)

        if redundancy_mode:
            if redundancy_mode == "OnlyMain" or redundancy_mode == "OnlySpare" or redundancy_mode == "Any":
                for edge in edges:
                    edge.redundancyMode = redundancy_mode
            else:
                raise ValueError("Invalid redundancy mode, must be 'OnlyMain', 'OnlySpare' or 'Any'.")

        return edges


class TopologySynchronize:
    def __init__(self) -> None:
        pass

    def say_hello(self):
        print("Hello from TopologySynchronize!")
